// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/fstcore.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// fstlib_version
int fstlib_version();
static SEXP _fstcore_fstlib_version_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(fstlib_version());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fstlib_version() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fstlib_version_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fststore
SEXP fststore(Rcpp::String fileName, SEXP table, SEXP compression, SEXP uniformEncoding);
static SEXP _fstcore_fststore_try(SEXP fileNameSEXP, SEXP tableSEXP, SEXP compressionSEXP, SEXP uniformEncodingSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::String >::type fileName(fileNameSEXP);
    Rcpp::traits::input_parameter< SEXP >::type table(tableSEXP);
    Rcpp::traits::input_parameter< SEXP >::type compression(compressionSEXP);
    Rcpp::traits::input_parameter< SEXP >::type uniformEncoding(uniformEncodingSEXP);
    rcpp_result_gen = Rcpp::wrap(fststore(fileName, table, compression, uniformEncoding));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fststore(SEXP fileNameSEXP, SEXP tableSEXP, SEXP compressionSEXP, SEXP uniformEncodingSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fststore_try(fileNameSEXP, tableSEXP, compressionSEXP, uniformEncodingSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fstmetadata
SEXP fstmetadata(Rcpp::String fileName);
static SEXP _fstcore_fstmetadata_try(SEXP fileNameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::String >::type fileName(fileNameSEXP);
    rcpp_result_gen = Rcpp::wrap(fstmetadata(fileName));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fstmetadata(SEXP fileNameSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fstmetadata_try(fileNameSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fstretrieve
SEXP fstretrieve(Rcpp::String fileName, SEXP columnSelection, SEXP startRow, SEXP endRow);
static SEXP _fstcore_fstretrieve_try(SEXP fileNameSEXP, SEXP columnSelectionSEXP, SEXP startRowSEXP, SEXP endRowSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::String >::type fileName(fileNameSEXP);
    Rcpp::traits::input_parameter< SEXP >::type columnSelection(columnSelectionSEXP);
    Rcpp::traits::input_parameter< SEXP >::type startRow(startRowSEXP);
    Rcpp::traits::input_parameter< SEXP >::type endRow(endRowSEXP);
    rcpp_result_gen = Rcpp::wrap(fstretrieve(fileName, columnSelection, startRow, endRow));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fstretrieve(SEXP fileNameSEXP, SEXP columnSelectionSEXP, SEXP startRowSEXP, SEXP endRowSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fstretrieve_try(fileNameSEXP, columnSelectionSEXP, startRowSEXP, endRowSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fsthasher
SEXP fsthasher(SEXP rawVec, SEXP seed, SEXP blockHash);
static SEXP _fstcore_fsthasher_try(SEXP rawVecSEXP, SEXP seedSEXP, SEXP blockHashSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type rawVec(rawVecSEXP);
    Rcpp::traits::input_parameter< SEXP >::type seed(seedSEXP);
    Rcpp::traits::input_parameter< SEXP >::type blockHash(blockHashSEXP);
    rcpp_result_gen = Rcpp::wrap(fsthasher(rawVec, seed, blockHash));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fsthasher(SEXP rawVecSEXP, SEXP seedSEXP, SEXP blockHashSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fsthasher_try(rawVecSEXP, seedSEXP, blockHashSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fstcomp
SEXP fstcomp(SEXP rawVec, SEXP compressor, SEXP compression, SEXP hash);
static SEXP _fstcore_fstcomp_try(SEXP rawVecSEXP, SEXP compressorSEXP, SEXP compressionSEXP, SEXP hashSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type rawVec(rawVecSEXP);
    Rcpp::traits::input_parameter< SEXP >::type compressor(compressorSEXP);
    Rcpp::traits::input_parameter< SEXP >::type compression(compressionSEXP);
    Rcpp::traits::input_parameter< SEXP >::type hash(hashSEXP);
    rcpp_result_gen = Rcpp::wrap(fstcomp(rawVec, compressor, compression, hash));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fstcomp(SEXP rawVecSEXP, SEXP compressorSEXP, SEXP compressionSEXP, SEXP hashSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fstcomp_try(rawVecSEXP, compressorSEXP, compressionSEXP, hashSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fstdecomp
SEXP fstdecomp(SEXP rawVec);
static SEXP _fstcore_fstdecomp_try(SEXP rawVecSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type rawVec(rawVecSEXP);
    rcpp_result_gen = Rcpp::wrap(fstdecomp(rawVec));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_fstdecomp(SEXP rawVecSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_fstdecomp_try(rawVecSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// getnrofthreads
SEXP getnrofthreads();
static SEXP _fstcore_getnrofthreads_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(getnrofthreads());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_getnrofthreads() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_getnrofthreads_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// setnrofthreads
int setnrofthreads(SEXP nrOfThreads);
static SEXP _fstcore_setnrofthreads_try(SEXP nrOfThreadsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type nrOfThreads(nrOfThreadsSEXP);
    rcpp_result_gen = Rcpp::wrap(setnrofthreads(nrOfThreads));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_setnrofthreads(SEXP nrOfThreadsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_setnrofthreads_try(nrOfThreadsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// hasopenmp
SEXP hasopenmp();
static SEXP _fstcore_hasopenmp_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(hasopenmp());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_hasopenmp() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_hasopenmp_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// restore_after_fork
void restore_after_fork(bool restore);
static SEXP _fstcore_restore_after_fork_try(SEXP restoreSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< bool >::type restore(restoreSEXP);
    restore_after_fork(restore);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _fstcore_restore_after_fork(SEXP restoreSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_fstcore_restore_after_fork_try(restoreSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _fstcore_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("int(*fstlib_version)()");
        signatures.insert("SEXP(*fststore)(Rcpp::String,SEXP,SEXP,SEXP)");
        signatures.insert("SEXP(*fstmetadata)(Rcpp::String)");
        signatures.insert("SEXP(*fstretrieve)(Rcpp::String,SEXP,SEXP,SEXP)");
        signatures.insert("SEXP(*fsthasher)(SEXP,SEXP,SEXP)");
        signatures.insert("SEXP(*fstcomp)(SEXP,SEXP,SEXP,SEXP)");
        signatures.insert("SEXP(*fstdecomp)(SEXP)");
        signatures.insert("SEXP(*getnrofthreads)()");
        signatures.insert("int(*setnrofthreads)(SEXP)");
        signatures.insert("SEXP(*hasopenmp)()");
        signatures.insert("void(*restore_after_fork)(bool)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _fstcore_RcppExport_registerCCallable() { 
    R_RegisterCCallable("fstcore", "_fstcore_fstlib_version", (DL_FUNC)_fstcore_fstlib_version_try);
    R_RegisterCCallable("fstcore", "_fstcore_fststore", (DL_FUNC)_fstcore_fststore_try);
    R_RegisterCCallable("fstcore", "_fstcore_fstmetadata", (DL_FUNC)_fstcore_fstmetadata_try);
    R_RegisterCCallable("fstcore", "_fstcore_fstretrieve", (DL_FUNC)_fstcore_fstretrieve_try);
    R_RegisterCCallable("fstcore", "_fstcore_fsthasher", (DL_FUNC)_fstcore_fsthasher_try);
    R_RegisterCCallable("fstcore", "_fstcore_fstcomp", (DL_FUNC)_fstcore_fstcomp_try);
    R_RegisterCCallable("fstcore", "_fstcore_fstdecomp", (DL_FUNC)_fstcore_fstdecomp_try);
    R_RegisterCCallable("fstcore", "_fstcore_getnrofthreads", (DL_FUNC)_fstcore_getnrofthreads_try);
    R_RegisterCCallable("fstcore", "_fstcore_setnrofthreads", (DL_FUNC)_fstcore_setnrofthreads_try);
    R_RegisterCCallable("fstcore", "_fstcore_hasopenmp", (DL_FUNC)_fstcore_hasopenmp_try);
    R_RegisterCCallable("fstcore", "_fstcore_restore_after_fork", (DL_FUNC)_fstcore_restore_after_fork_try);
    R_RegisterCCallable("fstcore", "_fstcore_RcppExport_validate", (DL_FUNC)_fstcore_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_fstcore_fstlib_version", (DL_FUNC) &_fstcore_fstlib_version, 0},
    {"_fstcore_fststore", (DL_FUNC) &_fstcore_fststore, 4},
    {"_fstcore_fstmetadata", (DL_FUNC) &_fstcore_fstmetadata, 1},
    {"_fstcore_fstretrieve", (DL_FUNC) &_fstcore_fstretrieve, 4},
    {"_fstcore_fsthasher", (DL_FUNC) &_fstcore_fsthasher, 3},
    {"_fstcore_fstcomp", (DL_FUNC) &_fstcore_fstcomp, 4},
    {"_fstcore_fstdecomp", (DL_FUNC) &_fstcore_fstdecomp, 1},
    {"_fstcore_getnrofthreads", (DL_FUNC) &_fstcore_getnrofthreads, 0},
    {"_fstcore_setnrofthreads", (DL_FUNC) &_fstcore_setnrofthreads, 1},
    {"_fstcore_hasopenmp", (DL_FUNC) &_fstcore_hasopenmp, 0},
    {"_fstcore_restore_after_fork", (DL_FUNC) &_fstcore_restore_after_fork, 1},
    {"_fstcore_RcppExport_registerCCallable", (DL_FUNC) &_fstcore_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

int avoid_openmp_hang_within_fork(DllInfo *dll);
RcppExport void R_init_fstcore(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
    avoid_openmp_hang_within_fork(dll);
}
